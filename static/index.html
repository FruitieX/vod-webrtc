<html>
	<head>
		<script src="jquery-2.1.1.min.js"></script>
	</head>
	<body>
		<video width=640 height=480 id="video" controls autoplay></video>
		<input type="file" id="fileSelector"/>
		<div id="stats"></div>
		<script>

var file;
var chunkSize = 1024 * 64;
var chunkBuffer = 10; // how many chunks to buffer
var bufMaxSeconds = 10; // how many seconds into the future to buffer at most

var video = document.querySelector('video');

var readFile = function(currentChunk, storeCallback) {
	var reader = new FileReader();
	reader.onload = function(e) {
		storeCallback(currentChunk, new Uint8Array(e.target.result));
		//sb.appendBuffer(new Uint8Array(e.target.result));
	};

	var blob = file.slice(currentChunk * chunkSize, (currentChunk + 1) * chunkSize);

	// asynchronously append to sourcebuffer
	reader.readAsArrayBuffer(blob);

	// signal caller that the entire file has been read
	if((currentChunk + 1) * chunkSize >= file.size) {
		console.log("EOF");
		return true;
	}
	return false;
}

$("#fileSelector").change(function(e) {
	file = e.target.files[0];
	var cnt = Math.ceil(file.size / chunkSize);
	videoHandler(video, readFile, cnt, chunkBuffer, bufMaxSeconds);
});

/* videoHandler
 *
 * Given a video element, callback function which fills a given arraybuffer,
 * and how many seconds we should buffer, this function will attach a
 * media source to the video element, fill the source buffer with data
 * by calling bufCallback until we have bufSeconds of buffer ahead of our
 * playing position.
 */

var videoHandler = function(videoElement, bufCallback, chunkCount, chunkBuffer, bufMaxSeconds) {
	// tempChunks contains any chunks not yet passed on to the sourceBuffer
	// As soon as a chunk is appended to the sourceBuffer, it is deleted from
	// tempChunks. Chunks are stored at their respective indices in tempChunks.
	// tempChunksCnt contains the current chunk count of tempChunks
	// pendingChunkCnt contains the count of pending chunk requests
	var tempChunks = [];
	var tempChunksCnt = 0; var pendingChunkCnt = 0; var largestChunk = 0;

	// sbChunk points to the chunk that we must append to the sourceBuffer next,
	// this should be the first chunk in tempChunks
	var sbChunk = 0;

	var ms = new MediaSource();
	var sb;

	videoElement.src = window.URL.createObjectURL(ms);

	// NOTE: if you get this too early then your .webm video probably does not
	// contain keyframes where chrome expects them, use this program for a fix:
	// https://github.com/acolwell/mse-tools
	ms.addEventListener('sourceclose', function(e) {
		console.log("MEDIA SOURCE CLOSED: " + e);
		ms = undefined;
	});

	ms.addEventListener('sourceopen', function() {
		sb = ms.addSourceBuffer('video/webm; codecs="vorbis,vp8"');

		// get first chunks
		for(var i = 0; i < chunkBuffer; i++)
			getChunk(i);

		// call appendChunks as soon as the sourceBuffer is ready to receive more data
		sb.addEventListener('updateend', function() {
			appendChunks();
		});
	}, false);

	var getChunk = function(currentChunk) {
		// already buffered the whole video?
		if(currentChunk >= chunkCount)
			return;

		//console.log('getChunk(): currentChunk: ' + currentChunk + ' sbChunk: ' + sbChunk + ' pendingChunkCnt: ' + pendingChunkCnt + ' chunkCount: ' + chunkCount);

		// if the buffer is not full, fetch more chunks.
		if(pendingChunkCnt < chunkBuffer) {
			if(currentChunk > largestChunk)
				largestChunk = currentChunk;

			//console.log(videoElement.buffered.length, videoElement.currentTime, bufMaxSeconds);
			if(videoElement.buffered.length && (videoElement.currentTime + bufMaxSeconds <= videoElement.buffered.end(0))) {
				//console.log(videoElement.buffered.end(0));
				//console.log("deferring getChunk()");
				setTimeout(function() {
					if(ms)
						getChunk(currentChunk);
				}, 1000);
			} else {
				bufCallback(currentChunk, storeCallback);
				pendingChunkCnt++;
			}
		} else {
			console.log("huh??? getChunk() called even though chunkBuffer is full!");
			/*
			*/
		}
	};

	setInterval(function() {
		// debug print
		if(videoElement.buffered.length)
			$("#stats").text("video played/buffered: " + Math.round(videoElement.currentTime) + 's/' + Math.round(videoElement.buffered.end(0)) + 's');
	}, 1000);

	/* Chunk handling */

	// attempt appending chunk at sbChunk
	// NOTE: this function is called when the sb event 'updateend' fires, that is,
	// when the sb has finished appending to its buffer. This means that this
	// function will 'loop' asynchronously whenever the sb is ready,
	// incrementing sbChunk each iteration, until we find the first chunk that
	// has not been fetched yet
	var appendChunks = function() {
		if(!tempChunks[sbChunk])
			return; // we are missing a chunk and can't continue

		// if the sb is already processing buffers we don't need to do anything here;
		// appendChunks(); will be called asynchronously when the sb has finished
		if(!sb.updating) {
			sb.appendBuffer(tempChunks[sbChunk]);

			delete(tempChunks[sbChunk]);
			tempChunksCnt--;

			sbChunk++;

			if(videoElement.paused)
				videoElement.play();
		}
	};

	// called whenever a new chunk has been fetched to store the new chunk
	var storeCallback = function(currentChunk, buf) {
		// as the sourceBuffer requires chunks to be in order, we must store this
		// chunk and append it once all chunks before it have been fetched.
		pendingChunkCnt--;

		// start fetching another chunk
		getChunk(largestChunk + 1);

		tempChunks[currentChunk] = buf;
		tempChunksCnt++;

		appendChunks();
	};

	// TODO handle failures
	var failCallback = function(currentChunk) {
	};
};
		</script>
	</body>
</html>

